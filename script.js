// Módulo Imperial v3.2
document.addEventListener('DOMContentLoaded', () => {
    const dom = {
        urlList: document.getElementById('urlList'), visits: document.getElementById('visitsInput'), concurrency: document.getElementById('concurrencyInput'), retries: document.getElementById('retriesInput'), retryDelay: document.getElementById('retryDelayInput'), refererList: document.getElementById('refererList'), userAgentList: document.getElementById('userAgentList'), proxyList: document.getElementById('proxyList'), visitButton: document.getElementById('visitButton'), stopButton: document.getElementById('stopButton'), verifyProxiesButton: document.getElementById('verify-proxies'), exportLogButton: document.getElementById('export-log'), exportCsvButton: document.getElementById('export-csv'), status: document.getElementById('status'), progressContainer: document.getElementById('progress-container'), progressBar: document.getElementById('progress-bar'), progressText: document.getElementById('progress-text'), resultsDashboard: document.getElementById('results-dashboard'), resultsTbody: document.querySelector('#results-table tbody'), presetSelect: document.getElementById('preset-select'), presetName: document.getElementById('preset-name'), savePresetButton: document.getElementById('save-preset'), deletePresetButton: document.getElementById('delete-preset'), themeToggle: document.getElementById('theme-toggle'),
        attackModeRadios: document.querySelectorAll('input[name="attackMode"]'), delaySettingsContainer: document.getElementById('delay-settings-container'), minDelay: document.getElementById('min-delay'), maxDelay: document.getElementById('max-delay'),
        resetMissionButton: document.getElementById('reset-mission'), resetLogButton: document.getElementById('reset-log'),
    };
    let isCancelled = false, logContent = '', missionResults = {};
    const SERVER_URLS = { visit: 'http://localhost:3000/execute-visit', verify: 'http://localhost:3000/verify-proxy' };
    
    window.openTab = (evt, tabName) => { document.querySelectorAll(".tab-content").forEach(tab => tab.style.display = "none"); document.querySelectorAll(".tab-link").forEach(link => link.classList.remove("active")); document.getElementById(tabName).style.display = "block"; evt.currentTarget.classList.add("active"); };
    const logMessage = (message, type = '') => { const fullMessage = `[${new Date().toLocaleTimeString()}] ${message}`; const el = document.createElement('div'); el.className = `status-message ${type}`; el.textContent = fullMessage; dom.status.appendChild(el); dom.status.scrollTop = dom.status.scrollHeight; logContent += fullMessage + '\n'; };
    const toggleControls = (enable) => { document.querySelectorAll('input, textarea, select, button').forEach(el => { if (el.id !== 'stopButton') el.disabled = !enable; }); };
    const setUiState = (isRunning) => { dom.visitButton.style.display = isRunning ? 'none' : 'block'; dom.stopButton.style.display = isRunning ? 'block' : 'none'; dom.progressContainer.style.display = isRunning ? 'block' : 'none'; const missionEnded = !isRunning && logContent.length > 0; dom.exportLogButton.style.display = missionEnded ? 'inline-block' : 'none'; dom.exportCsvButton.style.display = missionEnded && Object.keys(missionResults).length > 0 ? 'inline-block' : 'none'; dom.resultsDashboard.style.display = isRunning ? 'none' : (Object.keys(missionResults).length > 0 ? 'block' : 'none'); dom.resetMissionButton.style.display = missionEnded ? 'inline-block' : 'none'; dom.resetLogButton.style.display = missionEnded ? 'inline-block' : 'none';};
    const applyTheme = (theme) => { document.body.className = theme === 'dark' ? 'dark-mode' : ''; dom.themeToggle.checked = theme === 'dark';};
    const getDelay = () => { const min = parseInt(dom.minDelay.value, 10); const max = parseInt(dom.maxDelay.value, 10); return Math.floor(Math.random() * (max - min + 1) + min); };
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const PRESET_STORAGE_KEY = 'presets_v3_imperial_final';
    const getPresets = () => JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || {};
    const populatePresets = () => { const presets = getPresets(); dom.presetSelect.innerHTML = '<option value="">Cargar preset...</option>'; Object.keys(presets).forEach(name => dom.presetSelect.add(new Option(name, name))); };
    const savePreset = () => { const name = dom.presetName.value.trim(); if (!name) return alert('Nombre de preset requerido.'); const presets = getPresets(); presets[name] = { urls: dom.urlList.value, visits: dom.visits.value, concurrency: dom.concurrency.value, retries: dom.retries.value, retryDelay: dom.retryDelay.value, referers: dom.refererList.value, userAgents: dom.userAgentList.value, proxies: dom.proxyList.value, attackMode: document.querySelector('input[name="attackMode"]:checked').value, minDelay: dom.minDelay.value, maxDelay: dom.maxDelay.value }; localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets)); populatePresets(); dom.presetSelect.value = name; dom.presetName.value = ''; };
    const loadPreset = () => { const name = dom.presetSelect.value; if (!name) return; const p = getPresets()[name]; dom.urlList.value = p.urls || ''; dom.visits.value = p.visits || '10'; dom.concurrency.value = p.concurrency || '5'; dom.retries.value = p.retries || '2'; dom.retryDelay.value = p.retryDelay || '1500'; dom.refererList.value = p.referers || ''; dom.userAgentList.value = p.userAgents || ''; dom.proxyList.value = p.proxies || ''; dom.minDelay.value = p.minDelay || '300'; dom.maxDelay.value = p.maxDelay || '1500'; if (p.attackMode) { document.querySelector(`input[name="attackMode"][value="${p.attackMode}"]`).checked = true; } else { document.querySelector('input[name="attackMode"][value="brutal"]').checked = true; } const changeEvent = new Event('change'); dom.attackModeRadios[0].dispatchEvent(changeEvent); };
    const deletePreset = () => { const name = dom.presetSelect.value; if (!name || !confirm(`¿Borrar preset "${name}"?`)) return; const presets = getPresets(); delete presets[name]; localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets)); populatePresets(); };
    
    const verifyProxies = async () => { const proxies = dom.proxyList.value.split('\n').map(p => p.trim()).filter(Boolean); if (proxies.length === 0) return logMessage('No hay proxies para verificar.', 'warning'); dom.verifyProxiesButton.disabled = true; dom.verifyProxiesButton.classList.add('verifying'); logMessage(`Verificando ${proxies.length} proxies...`, 'info'); const verificationPromises = proxies.map(proxy => fetch(SERVER_URLS.verify, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ proxy }) }).then(res => res.json())); const results = await Promise.all(verificationPromises); const goodProxies = results.filter(r => r.success).map(r => r.proxy); dom.proxyList.value = goodProxies.join('\n'); dom.verifyProxiesButton.disabled = false; dom.verifyProxiesButton.classList.remove('verifying'); logMessage(`Verificación completa. ${goodProxies.length} de ${proxies.length} proxies operativos.`, 'info'); };
    
    const renderResultsTable = () => { dom.resultsTbody.innerHTML = ''; Object.values(missionResults).forEach(data => { const total = data.success + data.fail, rate = total > 0 ? (data.success / total) * 100 : 0, avgTime = data.times.length > 0 ? data.times.reduce((a, b) => a + b, 0) / data.times.length : 0; const row = `<tr><td title="${data.url}">${data.url}</td><td>${data.success}</td><td>${data.fail}</td><td>${rate.toFixed(1)}%</td><td>${Math.round(avgTime)}</td></tr>`; dom.resultsTbody.innerHTML += row; }); };
    const exportToCsv = () => { let csvContent = "URL,Exitos,Fallos,TasaExito(%),TiempoPromedio(ms)\n"; Object.values(missionResults).forEach(data => { const total = data.success + data.fail, rate = total > 0 ? (data.success / total) * 100 : 0, avgTime = data.times.length > 0 ? data.times.reduce((a, b) => a + b, 0) / data.times.length : 0; const row = `"${data.url}",${data.success},${data.fail},${rate.toFixed(1)},${Math.round(avgTime)}\n`; csvContent += row; }); const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.setAttribute("download", `reporte_mision_${new Date().toISOString()}.csv`); document.body.appendChild(link); link.click(); document.body.removeChild(link);};
    
    const executeOrder = async (order) => {try {const response = await fetch(SERVER_URLS.visit, {method: 'POST',headers: { 'Content-Type': 'application/json' },body: JSON.stringify(order)});const result = await response.json();if (!response.ok) throw new Error(result.message || 'Error en Relay');return result;} catch (error) {return { success: false, status: 'RELAY_ERROR', message: `Fallo de comunicación con Relay: ${error.message}` };}};
    const startVisits = async () => { isCancelled = false; missionResults = {}; const urls = dom.urlList.value.split('\n').map(u => u.trim()).filter(Boolean); if (urls.length === 0) return alert('Introduce al menos una URL.'); const vpu = parseInt(dom.visits.value,10), conc = parseInt(dom.concurrency.value,10), rtrs = parseInt(dom.retries.value,10), rtrD = parseInt(dom.retryDelay.value,10); const rfrs = dom.refererList.value.split('\n').map(u => u.trim()).filter(Boolean); const uas = dom.userAgentList.value.split('\n').map(u => u.trim()).filter(Boolean); const prxs = dom.proxyList.value.split('\n').map(u => u.trim()).filter(Boolean); const attackMode = document.querySelector('input[name="attackMode"]:checked').value; const allTasks = []; for (const url of urls) { for (let i=0; i < vpu; i++) allTasks.push({url}); missionResults[url] = { url, success: 0, fail: 0, times: [] }; } let tasksCompleted = 0; const totalTasks = allTasks.length; toggleControls(false); setUiState(true); dom.status.innerHTML = ''; logContent = ''; logMessage(`Iniciando Misión [Modo: ${attackMode.charAt(0).toUpperCase() + attackMode.slice(1)}] | ${totalTasks} visitas | Concurrencia: ${conc}`, 'info'); const worker = async () => { while (allTasks.length > 0) { if (isCancelled) return; const task = allTasks.shift(); const headers = {}; if (uas.length) headers['User-Agent'] = uas[Math.floor(Math.random() * uas.length)]; if (rfrs.length) headers['Referer'] = rfrs[Math.floor(Math.random() * rfrs.length)]; const order = { targetUrl: task.url, proxy: prxs.length ? prxs[tasksCompleted % prxs.length] : null, headers, retries: rtrs, retryDelay: rtrD}; const report = await executeOrder(order); tasksCompleted++; const r = missionResults[task.url]; if (report.success) {r.success++; r.times.push(report.duration);} else {r.fail++;} logMessage(`${report.success ? '✅':'❌'} [${report.status||'ERROR'}] ${task.url} ${report.success ? `(${report.duration}ms)`:`| Fallo: ${report.message}`}`, report.success ? 'success':'error'); dom.progressBar.style.width = `${(tasksCompleted / totalTasks) * 100}%`; dom.progressText.textContent = `${tasksCompleted} / ${totalTasks}`; if (attackMode === 'tactical' && !isCancelled && allTasks.length > 0) {await sleep(getDelay());} } }; await Promise.all(Array(conc).fill(null).map(worker)); logMessage(isCancelled ? 'MISIÓN ABORTADA.':'MISIÓN COMPLETADA.', isCancelled?'warning':'info'); renderResultsTable(); toggleControls(true); setUiState(false); };
    
    const resetMission = () => { if (confirm("¿Seguro que quieres reiniciar? Se perderá el reporte actual.")) { location.reload(); }};
    dom.visitButton.addEventListener('click', startVisits);
    dom.stopButton.addEventListener('click', () => isCancelled = true);
    dom.attackModeRadios.forEach(radio => radio.addEventListener('change', () => { dom.delaySettingsContainer.style.display = document.querySelector('input[name="attackMode"]:checked').value === 'tactical' ? 'block' : 'none'; }));
    dom.savePresetButton.addEventListener('click', savePreset);
    dom.presetSelect.addEventListener('change', loadPreset);
    dom.deletePresetButton.addEventListener('click', deletePreset);
    dom.verifyProxiesButton.addEventListener('click', verifyProxies);
    dom.exportLogButton.addEventListener('click', () => { /* Add export log logic here if needed */});
    dom.exportCsvButton.addEventListener('click', exportToCsv);
    dom.themeToggle.addEventListener('change', () => { const newTheme = dom.themeToggle.checked ? 'dark' : 'light'; localStorage.setItem('theme', newTheme); applyTheme(newTheme); });
    dom.resetMissionButton.addEventListener('click', resetMission);
    dom.resetLogButton.addEventListener('click', resetMission);
    
    (() => { applyTheme(localStorage.getItem('theme') || 'dark'); populatePresets(); document.querySelector('.tab-link').click(); const changeEvent = new Event('change'); dom.attackModeRadios[0].dispatchEvent(changeEvent); })();
});